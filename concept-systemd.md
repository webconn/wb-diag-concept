WB diagnostics implementation concept - systemd
===============================================

Концепт описывает использование systemd-journald в качестве бэкенда.

Описание
--------

Как я говорил ранее, диагностика - это сообщение из одного конкретного места
в программе, которая может сообщить, что в этом месте всё хорошо, или что
есть проблема.

Диагностика в один момент времени - это запись с полями:

 * имя диагностики (путь в дереве) - имеет вид `/subsystemM/subsubN/../diagX`;
 * статус (ok, warn, error) - отражает общее настроение диагностики;
 * описание состояния в виде текстового сообщения;
 * (опционально) дополнительные поля.

Когда состояние меняется, сервис отправляет новую запись с новыми данными,
после чего она записывается в историю и отображается в интерфейсе.

(Всё это очень сильно напоминает обычный лог с дополнительными полями. А это
уже умеет systemd-journald.)

Хранить информацию о диагностиках в systemd-journald **удобно**, потому что:

 * journald - это удобное место для хранения логов (условимся, что
   диагностики - это почти логи). Это означает, что при необходимости
   записи диагностик можно будет извлечь с помощью простого journalctl,
   и лог получится вполне осмысленным => пользователи, привыкшие читать
   логи через штатные средства, не потеряют информацию;
 * каждой записи в лог можно сопоставить ID сообщения (в виде 128-битного
   int, например, UUID, либо как хеш от пути) - это штатная фича journald,
   и есть вероятность, что сообщения индексируются по ID и их можно будет
   быстро извлекать;
 * у systemd-journald есть API для работы с логами на разных языках;
 * в systemd-journald есть штатная возможность хранить дополнительные поля.


И в то же время это может оказаться **неудобно**, потому что (TODO: проверить
доводы на практике):

 * в записях явным образом не делается древовидная структура категорий.
   Нужно будет формировать её и поддерживать снаружи.
   Для фильтрации категорий нужно будет продумать механизм (либо собирать
   по дереву массив message id и фильтровать по нему, либо ещё как-то);
 * log rotation не подконтролен нам в плане выбора удаляемых сообщений,
   из-за этого есть шанс потерять информацию в редко обновляемых диагностиках
   из-за переполнения логов;
 * из journald может быть проблематично извлечь последние записи по
   каждой из диагностик (нужно проверить на практике, работает ли индексация
   по message id, или сколько времени занимает выборка сообщений из лога на
   контроллере);
 * нужна возможность быстро получать новые сообщения диагностик по мере их
   появления в логе (проверить это в документации journald).


Что нужно будет доделывать:

 * транспорт для передачи логов в web-интерфейс;
 * сервис для выгрузки диагностик из journald и выдачи их по API.


Детали реализации
=================

Запись диагностики
------------------

Альтернативные системы сбора логов
----------------------------------

 * logstash
 * rsyslog
 * ELK
